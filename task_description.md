# Завдання:
   Реалізувати функціонал сторінки відповідно до демонстрації
   Посилання на демонстрацію: https://youtu.be/BGwU9ehApc8

## Вимоги
   1. Назви змінних повинні відповідати контенту, який ми їм присвоюємо, не використовувати назви типу a, b тощо. Виняток - назви ітераторів в циклах (for let i = 0 тощо).
   2. Назви функцій - мають коротко описувати дію (або не дуже коротко). Назва має бути змістовною і зрозумілою
   3. За можливості уникаємо дублювання дій. Якщо помічаємо, що виконуємо однотипний набір дій - значить, можна трохи прокачати код, написавши функцію, яка виконуватиме однотипні дії за нас.
   4. Дії до обробників подій виносимо окремо, щоб в обробнику подій було мінімум коду - виклики функції, наприклад. Як ми це робили в 13 ДЗ.
   5. Нічого не додаємо і не видаляємо з файлів index.html та style.css
   6. Користуємося знаннями, набутими в попередніх уроках. Для виконання проєкту, не потребуються методи та властивості, про які не було інформації в відеоуроках. Але не забороняється їх використовувати, якщо ознайомилися самостійно і розумієте, як це працює.  

## Поради
   1. Винесіть основні елемент розмітки (з index.html), що будуть задіяні в процесі створення проєкта, вгорі файлу main.js в змінні (const або let). Задайте для них зрозумілі назви. 
   2. Після ознайомлення з деталями проєкту в цьому файлі, пробуємо розбити функціонал проєкта на дрібніші підзадачі (для себе). Визначаємо, які функції нам знадобляться для функціонування тих чи інших елементів, які параметри ці функції прийматимуть, що відбуватиметься на сторінці після їхнього використання, в який саме момент і в якій послідовності функції будуть працювати. 
   Важливо хоча б мінімально продумати структуру проєкта, намітити шлях виконання, логіку.

## З чого почати
   ### Ознайомитися з файлами проєкта:
   - зображення в папці images (шляхи до цих зображень вже є в масиві з відео)
   - шаблони у папці temlplates (розмітку з цих файлів треба використовувати в js)
   - основний файл розмітки index.html (подивитися на елементи, що є в розмітці, які класи використовують)
   - основний файл стилів style.css (подивитися на класи, які можуть знадобитися для роботи в файлі main.js)
   - файл для роботи над проєктом - main.js (початково містить масив з об'єктами)

   ### Опис масиву з відео(videos)
      Файл main.js містить масив з об'єктами. Кожен з об'єктів у масиві зберігає інформацію про відео. Значення кожної з властивостей бере участь у наповненні картки відео. Треба самостійно знайти місця для інформації з об'єктів у розмітці картки (шаблон самої картки в папці templates - film-card.html). 

   * title - назва відео. 
   * duration - тривалість відео у секундах. У розмітці має бути у форматі хвилини:секунди (як в демонстрації)
   * thumbnail - фонове зображення-обкладинка для відео 
   * avatar - картинка-логотип студії 
   * studio - назва студії
   * linkId - ідентифікатор відео з youtube. Для того щоб сформувати повноцінне посилання на відео треба використати "https://www.youtube.com/embed/" і вже потім доклеювати до цього посилання номер ідентифікатора 
   * likes - кількість вподобайок. Детальніше про формат виводу на картці в окремому пункті "Формат чисел"
   * views - кількість переглядів. Детальніше про формат виводу на картці в окремому пункті "Формат чисел"
   * year - рік випуску фільму
   * channelId - ідентифікатор каналу youtube. Щоб сформувати посилання на канал треба до "https://www.youtube.com/" доклеїти назву(ідентифікатор)

   ## Функціональність
      Уся функціональність описана і показана у відеодемонстрації - https://youtu.be/BGwU9ehApc8
      Нижче короткі описи функцій елементів

      ### кнопка "Показати фільми"
         Після кліку по кнопці(js_show) додається можливість пошуку відео за назвою; також після кліку бачимо усі фільми (всередині video-list) та фільтри, тобто формуються і додаються картки фільмів
      
      ### кнопка "Пошук за назвою" 
         Після кліку(js_search) маємо отримати дані. Шукаємо і виводимо картки за найменшим збігом. Тобто якщо ввели "th", то отримаємо картки з усіма відео, де є це буквосполучення.
         При помилці додаємо повідомлення в потрібне місце в message-box, показуємо його.
         Не забуваємо що повідомлення має закриватися

      ### кнопки фільтрів
         У розмітці(index.html) у кожної такої кнопки є data-атрибут data-filter з власним значенням, ці фільтри і використовуємо для функціоналу. 
         Для сортування за більшістю категорій потрібна буде функція, що сортує масив за певними параметрами. Приклад подібної функції в кінці цього файлу

      * "Усі" - показує усі картки з відео в тому ж порядку, в якому вони лежать в масиві
      * "Найбільше переглядів" - буквально сортує картки за кількістю переглядів. Спочатку відео з найбільшою кількістю переглядів, а в кінці з найменшою.
      * "Найбільше вподобали", "Найдовші", "Новіші" - працюватимуть аналогічно з "Найбільше переглядів", але сортуватимуться за своїми параметрами - вподобайками, тривалістю, роком відповідно
      * "Найменше переглядів", "Найменше вподобали", Найкоротші", "Старіші" - фактично перевертають сформовані в попередніх циклах масиви
      * "Студії" - маємо показати список унікальних (без повторень) студій (В index.html вже є елемент, studio-list, куди їх треба додавати). Внизу документа є підказка щодо. При клікові на конкретну студію показуємо картки з відео, які належать саме цій студії. Тут згодиться значення з атрибута data-studio. Наглядніше у відеодемонстрації

      # зображення відео (клік по зображенню)
       При клікові передаємо data-href поточної картки з відео в потрібне місце в popup, показуємо сам popup з відео. При клікові на "Закрити" - закривається popup 
      

   # Формат чисел (вподобайки та перегляди) 
      В об'єктах карток вподобайки та перегляди у форматі чисел. 
      В картці з фільмом ці числа відображені дещо в іншому форматі
      Значення повинні округлятися наступним чином:
      Тисячі: 6542 - 6.5тис
      Мільйони: 1234987 - 1.2 млн

   # приклад функції для сортування від більшого до меншого
   /* 
   Звісно, що для правильної роботи в проєкті функцію треба вдосконалити (наприклад, додати параметри, за якими відбуватиметься фільтрування, визначити, що саме буде порівнюватися тощо)
   ```
      function sortByViews(arr) {
      const arr = [...arr]; // клонуємо оригінальний масив
      const sortedArr = [];

      for (let i = arr.length; i > 0; i--) {
         let maxIndex = 0; // встановлюємо maxIndex (індекс максимального елемента) на початку кожної ітерації на 0.

         /*Порівнюємо значення елемента arr[j] зі значенням елемента arr[maxIndex]. Якщо arr[j] більше, ніж arr[maxIndex], то оновлюємо maxIndex на j, що означає, що знайдено новий найбільший елемент.*/
         for (let j = 1; j < i; j++) {
            if (arr[j] > arr[maxIndex]) {
            maxIndex = j;
            }
         }

         /*
            Після завершення внутрішнього циклу маємо знайдений максимальний елемент в невідсортованій частині масиву arr (від 0 до i). Додаємо це значення в кінець sortedArr за допомогою sortedArr.push(arr[maxIndex]).
         */
         sortedArr.push(arr[maxIndex]);
         /*
            Видаляємо максимальний елемент з масиву arr за допомогою arr.splice(maxIndex,1) Це дасть нам змогу більше не враховувати найбільше значення в наступних ітераціях внутрішнього циклу.
         */
         arr.splice(maxIndex, 1);
      }

      return sortedArr;
      }
   ```